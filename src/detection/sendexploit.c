/*
 * Polyvaccine a Polymorphic exploit detection engine.
 *
 * Copyright (C) 2009  Luis Campo Giralte
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 * Written by Luis Campo Giralte <luis.camp0.2009@gmail.com> 2009
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbus/dbus.h>
#include "examples.h"

void sendbuffer(unsigned char *buffer,int size){
	DBusError err;
   	DBusConnection* conn;
   	int ret,i;
   
	dbus_error_init(&err);
   	conn = dbus_bus_get(DBUS_BUS_SESSION, &err);
   	if (dbus_error_is_set(&err)) { 
      		fprintf(stderr, "Connection Error (%s)\n", err.message); 
      		dbus_error_free(&err); 
   	}
	if(conn == NULL) {
		exit(-1);
	}
   	ret = dbus_bus_request_name(conn, "test.method.server", 
        	DBUS_NAME_FLAG_REPLACE_EXISTING 
         	,&err);
   	if (dbus_error_is_set(&err)) { 
      		fprintf(stderr, "Name Error (%s)\n", err.message); 
      		dbus_error_free(&err); 
   	}
	if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) { 
      		exit(1);
   	}

   	DBusMessage* msg;
   	DBusMessageIter args;
 
	msg = dbus_message_new_signal("/polyvaccine/detector", // object name of the signal
        	"polyvaccine.detector.analyze", // interface name of the signal
         	"analyze"); // name of the signal
	if (NULL == msg){ 
      		fprintf(stderr, "Message Null\n"); 
      		exit(1); 
	}

	unsigned char *newbuffer = malloc(1024);
	memset(newbuffer,0,1024);
	memcpy(newbuffer,buffer,size);
	dbus_message_append_args(msg,DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &newbuffer, size, DBUS_TYPE_INVALID);

	printf("sending signal to bus\n");
	if (!dbus_connection_send(conn, msg, NULL)) { 
      		fprintf(stderr, "Out Of Memory!\n"); 
      		exit(1);
   	}
   	dbus_connection_flush(conn);
   	dbus_message_unref(msg);
}


void main() {
	unsigned char *buffer = admmutate_1; 
	int len = size_admmutate_1; 

	unsigned char *pepe = "buenos idas leches en vinagre";

	printf("Sending buffer\n");
	sendbuffer(buffer,len);
	printf("done \n");
	return;

}
