/*
 * Polyvaccine a Polymorphic exploit detection engine.
 *
 * Copyright (C) 2009  Luis Campo Giralte
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 * Written by Luis Campo Giralte <luis.camp0.2009@gmail.com> 2009
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbus/dbus.h>
#include "examples.h"
#include "examples64.h"
#include <getopt.h>

#define MAX_EXECUTION_BUFFER 2048

void sendbuffer(unsigned char *buffer,int size){
	DBusError err;
   	DBusConnection* conn;
	DBusMessageIter iter,dataIter;
   	int ret,i;
   
	dbus_error_init(&err);
   	conn = dbus_bus_get(DBUS_BUS_SESSION, &err);
   	if (dbus_error_is_set(&err)) { 
      		fprintf(stderr, "Connection Error (%s)\n", err.message); 
      		dbus_error_free(&err); 
   	}
	if(conn == NULL) {
		exit(-1);
	}
   	ret = dbus_bus_request_name(conn, "test.method.server", 
        	DBUS_NAME_FLAG_REPLACE_EXISTING 
         	,&err);
   	if (dbus_error_is_set(&err)) { 
      		fprintf(stderr, "Name Error (%s)\n", err.message); 
      		dbus_error_free(&err); 
   	}
	if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) { 
      		exit(1);
   	}

   	DBusMessage* msg;
   	DBusMessageIter args;
 
	msg = dbus_message_new_signal("/polyvaccine/detector", // object name of the signal
        	"polyvaccine.detector.analyze", // interface name of the signal
         	"Analyze"); // name of the signal
	if (NULL == msg){ 
      		fprintf(stderr, "Message Null\n"); 
      		exit(1); 
	}

	dbus_uint32_t hash = 5000;
	dbus_uint32_t seq = 128;
	unsigned char *newbuffer = malloc(MAX_EXECUTION_BUFFER);
	memset(newbuffer,0,MAX_EXECUTION_BUFFER);
	memcpy(newbuffer,buffer,size);

	/* Sends a full segment to the detector
	 * 
	 * 1 - arrray with the buffer and its lenght.
	 * 2 - the hash of the connection flow.
	 * 3 - the sequence number.
	 */
	dbus_message_iter_init_append(msg,&iter);
	dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE_AS_STRING, &dataIter);
        dbus_message_iter_append_fixed_array(&dataIter, DBUS_TYPE_BYTE, &newbuffer, size);
        dbus_message_iter_close_container(&iter, &dataIter);

	dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&hash);
	dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&seq);

	printf("sending signal to bus\n");
	if (!dbus_connection_send(conn, msg, NULL)) { 
      		fprintf(stderr, "Out Of Memory!\n"); 
      		exit(1);
   	}
   	dbus_connection_flush(conn);
   	dbus_message_unref(msg);
}

void usage(char *prog) {
	fprintf(stdout,"Use %s <case number>\n",prog);
	fprintf(stdout,"Test cases:\n");
	fprintf(stdout,"\t1 - Executes 64 bits exit 1 syscall\n");
	fprintf(stdout,"\t2 - Executes 64 bits exit 9 syscall\n");
	fprintf(stdout,"\t3 - Executes 32 bits exit 0 syscall\n");
	fprintf(stdout,"\t4 - Executes 32 bits loop for with write syscall\n");
	fprintf(stdout,"\t5 - Executes 32 bits admmutate engine with write syscall\n");
	fprintf(stdout,"\t6 - Executes 32 bits encoder fnstenv engine with shellcode\n");
	fprintf(stdout,"\t7 - Executes 32 bits eggdrop exploit\n");
	fprintf(stdout,"\t8 - Executes 32 bits apache exploit\n");
	fprintf(stdout,"\n");
	return;
}

void main(int argc, char **argv) {
	int len,case_n,c;
	unsigned char *buffer = NULL;

	printf("argc=%d\n",argc);
	if(argc== 2){
		case_n = atoi(argv[1]);
	}else{
		usage(argv[0]);
		exit(-1);
	}

	switch(case_n) {
		case 1:
             		buffer = exit_1_64bits;
			len = size_exit_1_64bits;	
             		break;
		case 2:
             		buffer = exit_9_64bits;
			len = size_exit_9_64bits;
			break;
		case 3:
			buffer = exit_0_32bits;
			len = size_exit_0_32bits;
			break;
		case 4:
			buffer = bucle_1_32bits;
			len = size_bucle_1_32bits;
			break;
		case 5:
			len = size_admmutate_1_32bits;
			buffer = admmutate_1_32bits;
			break;
		case 6:
			len = size_fnstenv_1_32bits;
			buffer = fnstenv_1_32bits;
			break;
		case 7:
			len = size_eggdrop_32bits;
			buffer = eggdrop_32bits;
			break;
		case 8:
			buffer = apache_32bits;
			len = size_apache_32bits;
			break;
           	default:
             		abort ();
	}
	if(buffer == NULL) {
		usage(argv[0]);
		exit(0);
	}
	printf("Sending buffer\n");
	sendbuffer(buffer,len);
	printf("done \n");
	return;

}
